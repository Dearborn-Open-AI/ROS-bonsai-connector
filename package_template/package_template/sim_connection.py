from typing import Dict
import math
import numpy as np
import os
import json
import time

# ROS
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState, LaserScan, Imu
from geometry_msgs.msg import Pose, Twist, Quaternion, Transform, Point, Vector3
from nav_msgs.msg import Odometry
import tf2_ros
from tf2_msgs.msg import TFMessage
from std_msgs.msg import Header, Float64, Float32
from std_srvs.srv import Empty
from ament_index_python.packages import get_package_share_directory

# import Microsoft Bonsai dependencies
from microsoft_bonsai_api.simulator.client import BonsaiClient, BonsaiClientConfig
from microsoft_bonsai_api.simulator.generated.models import (
    SimulatorInterface,
    SimulatorState,
    SimulatorSessionResponse,
)

from azure.core.exceptions import HttpResponseError

class SimulatorConnection(TurtleBot3BonsaiConnection):
    def __init__(self, package, config_file):
        # Calls Node.__init__('listener')
        super().__init__(NODE_NAME)

        # API for for resetting the simulation environment
        #   Gazebo Example:
        # self.reset_client = self.create_client(Empty, "/reset_world")
        
        # while not self.reset_client.wait_for_service(timeout_sec=5.0):
        #     self.get_logger().info('service not available, waiting again...')

        # LOAD BONSAI CONFIG
        with open(os.path.join(get_package_share_directory(package), config_file)) as file:
            self.interface = json.load(file)

        self.iteration = 0
        self.episode = 0

        self.sim_delay = 0.0
        self.state = {}
        self.episode_config = {}
        self.done = False

        self.event_timer = self.create_timer(
            0.250,  # unit: s
            self.event_callback)

    def step(self, actions: dict):
        """
        Function executed each time step.
        Here we get actions from Bonsai, execute them in a time step in the simulator,
        and retrieve the observations generated by that action.
        :param action:
        """
        # PARSE ACTIONS FROM BONSAI
        for action, value in actions.items():
            if action == "<action name>": 
                # parse action and assign to ros message (eg: Twist() to be published to /cmd_vel)
                self.get_logger().debug(
                    "Action {} of value {} received".format(action, value))

        # publish action message to ROS topic

        time.sleep(0.1)  # Wait for some time to execute sim state change
        
        # RETRIEVE OBSERVATIONS FROM SIMULATION
        # AND TRANSLATE TO BONSAI RECOGNIZABLE STATE TUPLE
        # Eg: self.state["temperature"] = simulation.temperature

        # end of step

    def reset(self):
        # Reset simulation

        # step with empty action space to retrieve state data post-rest
        self.step({})
        self.event_timer.reset()
        
        # Load episode config data to state space

    def get_episode_config(self, config: dict):
        self.episode_config = config
        self.get_logger().debug(
            "Episode config loaded:\n{}".format(json.dumps(config, indent=2))
        )

    def halted(self) -> bool:
        """Halt current episode. Note, this should only return True if the simulator has reached an unexpected state.
        Returns
        -------
        bool
            Whether to terminate current episode
        """
        return False

    def get_event(self):

        sim_state = SimulatorState(
            sequence_id=self.sequence_id, state=self.state, halted=self.halted(),
        )

        self.get_logger().debug(
            "SimulatorState: \n{}".format(json.dumps(sim_state.state, indent=2))
        )

        try:
            event = self.client.session.advance(
                workspace_name=self.config_client.workspace,
                session_id=self.registered_session.session_id,
                body=sim_state,
            )
            self.sequence_id = event.sequence_id
            # self.get_logger().info(
            #     "[{}] Last Event: {}".format(time.strftime("%H:%M:%S"), event.type)
            # )
        except HttpResponseError as ex:
            self.get_logger().error(
                "HttpResponseError in Advance: StatusCode: {}, Error: {}, Exception: {}".format(
                    ex.status_code, ex.error.message, ex
                )
            )
            # This can happen in network connectivity issue, though SDK has retry logic, but even after that request may fail,
            # if your network has some issue, or sim session at platform is going away..
            # So let's re-register sim-session and get a new session and continue iterating. :-)
            self.registered_session, self.sequence_id = self.CreateSession(self.registration_info, self)
        except Exception as err:
            self.get_logger().error("Unexpected error in Advance: {}".format(err))
            # Ideally this shouldn't happen, but for very long-running sims It can happen with various reasons, let's re-register sim & Move on.
            # If possible try to notify Bonsai team to see, if this is platform issue and can be fixed.
            self.registered_session, self.sequence_id = self.CreateSession(self.registration_info, self)

        return event

    def event_callback(self):
        event = self.get_event()

        # Event loop
        if event.type == "Idle":
            time.sleep(event.idle.callback_time)
            self.get_logger().info("Idling...")

        elif event.type == "EpisodeStart":
            self.episode += 1
            self.get_logger().info("Episode {} Starting...".format(self.episode))
            config = event.episode_start.config

            if config is None:
                raise ValueError("No episode start config received from Bonsai")

            self.get_episode_config(config)
            self.reset()

        elif event.type == "EpisodeStep":
            self.iteration += 1
            self.step(event.episode_step.action)

        elif event.type == "EpisodeFinish":
            self.get_logger().info("Episode {} Finishing...".format(self.episode))
            self.iteration = 0

        elif event.type == "Unregister":
            self.get_logger().info(
                "Simulator Session unregistered by platform because {}".format(
                    event.unregister.details
                )
            )

    def register_simulator(self):

        # Get keys to connect to Bonsai Workspace
        try:
            self.workspace = os.environ["SIM_WORKSPACE"]
            self.accesskey = os.environ["SIM_ACCESS_KEY"]
        except:
            raise IndexError(
                f"Workspace or access key not set or found. Use --config-setup for help setting up."
            )

        # Configure client to interact with Bonsai service
        self.config_client = BonsaiClientConfig()
        self.client = BonsaiClient(self.config_client)

        # Create simulator session and init sequence id
        self.registration_info = SimulatorInterface(
            name=SIM_NAME,
            timeout=self.interface["timeout"],
            simulator_context=self.config_client.simulator_context,
            description=self.interface["description"],
        )

        self.registered_session, self.sequence_id = self.CreateSession(self.registration_info)

    def CreateSession(
        self,
        registration_info: SimulatorInterface
    ):
        """Creates a new Simulator Session and returns new session, sequenceId
        """

        try:
            self.get_logger().info(
                "config: {}, {}".format(self.config_client.server, self.config_client.workspace)
            )
            registered_session: SimulatorSessionResponse = self.client.session.create(
                workspace_name=self.config_client.workspace, body=registration_info
            )
            self.get_logger().info("Registered simulator. {}".format(registered_session.session_id))

            return registered_session, 1
        except HttpResponseError as ex:
            self.get_logger().info(
                "HttpResponseError in Registering session: StatusCode: {}, Error: {}, Exception: {}".format(
                    ex.status_code, ex.error.message, ex
                )
            )
            raise ex
        except Exception as ex:
            self.get_logger().error(
                "UnExpected error: {}, Most likely, it's some network connectivity issue, make sure you are able to reach bonsai platform from your network.".format(
                    ex
                )
            )
        raise ex



